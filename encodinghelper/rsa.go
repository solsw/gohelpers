package encodinghelper

import (
	"bytes"
	"crypto/rsa"
	"math/big"
)

// RsaPublicKeyToBuffer writes rsa.PublicKey to bytes.Buffer.
func RsaPublicKeyToBuffer(b *bytes.Buffer, pub *rsa.PublicKey) {
	BigIntToBuffer(b, pub.N)
	Int64ToBuffer(b, int64(pub.E))
}

// RsaPublicKeyFromBuffer reads rsa.PublicKey from bytes.Buffer.
func RsaPublicKeyFromBuffer(b *bytes.Buffer) (*rsa.PublicKey, error) {
	n, err := BigIntFromBuffer(b)
	if err != nil {
		return nil, err
	}
	e, err := Int64FromBuffer(b)
	if err != nil {
		return nil, err
	}
	return &rsa.PublicKey{N: n, E: int(e)}, nil
}

// RsaPublicKeyMarshalBinary encodes rsa.PublicKey into a binary form.
func RsaPublicKeyMarshalBinary(pub *rsa.PublicKey) []byte {
	b := &bytes.Buffer{}
	// since bytes.Buffer.Write never returns an error (see help),
	// the returned by Writes errors are ignored
	RsaPublicKeyToBuffer(b, pub)
	return b.Bytes()
}

// RsaPublicKeyUnmarshalBinary decodes rsa.PublicKey from the binary form generated by RsaPublicKeyMarshalBinary.
func RsaPublicKeyUnmarshalBinary(data []byte) (*rsa.PublicKey, error) {
	b := bytes.NewBuffer(data)
	pub, err := RsaPublicKeyFromBuffer(b)
	if err != nil {
		return nil, err
	}
	return pub, nil
}

// RsaPrivateKeyToBuffer writes rsa.PrivateKey to bytes.Buffer.
func RsaPrivateKeyToBuffer(b *bytes.Buffer, priv *rsa.PrivateKey) {
	RsaPublicKeyToBuffer(b, &(priv.PublicKey))
	BigIntToBuffer(b, priv.D)
	Int64ToBuffer(b, int64(len(priv.Primes)))
	for _, prime := range priv.Primes {
		BigIntToBuffer(b, prime)
	}
	BigIntToBuffer(b, priv.Precomputed.Dp)
	BigIntToBuffer(b, priv.Precomputed.Dq)
	BigIntToBuffer(b, priv.Precomputed.Qinv)
	Int64ToBuffer(b, int64(len(priv.Precomputed.CRTValues)))
	for _, crtvalue := range priv.Precomputed.CRTValues {
		BigIntToBuffer(b, crtvalue.Exp)
		BigIntToBuffer(b, crtvalue.Coeff)
		BigIntToBuffer(b, crtvalue.R)
	}
}

func precomputedValuesFromBuffer(b *bytes.Buffer) (*rsa.PrecomputedValues, error) {
	dp, err := BigIntFromBuffer(b)
	if err != nil {
		return nil, err
	}
	dq, err := BigIntFromBuffer(b)
	if err != nil {
		return nil, err
	}
	qinv, err := BigIntFromBuffer(b)
	if err != nil {
		return nil, err
	}
	crtValuesLen, err := Int64FromBuffer(b)
	if err != nil {
		return nil, err
	}
	var crtValues []rsa.CRTValue
	var i int64
	for i = 0; i < crtValuesLen; i++ {
		exp, err := BigIntFromBuffer(b)
		if err != nil {
			return nil, err
		}
		coeff, err := BigIntFromBuffer(b)
		if err != nil {
			return nil, err
		}
		r, err := BigIntFromBuffer(b)
		if err != nil {
			return nil, err
		}
		crtValues = append(crtValues, rsa.CRTValue{Exp: exp, Coeff: coeff, R: r})
	}
	return &rsa.PrecomputedValues{Dp: dp, Dq: dq, Qinv: qinv, CRTValues: crtValues}, nil
}

// RsaPrivateKeyFromBuffer reads rsa.PrivateKey from bytes.Buffer.
func RsaPrivateKeyFromBuffer(b *bytes.Buffer) (*rsa.PrivateKey, error) {
	pub, err := RsaPublicKeyFromBuffer(b)
	if err != nil {
		return nil, err
	}
	d, err := BigIntFromBuffer(b)
	if err != nil {
		return nil, err
	}
	primesLen, err := Int64FromBuffer(b)
	if err != nil {
		return nil, err
	}
	var primes []*big.Int
	var i int64
	for i = 0; i < primesLen; i++ {
		prime, err := BigIntFromBuffer(b)
		if err != nil {
			return nil, err
		}
		primes = append(primes, prime)
	}
	precomputedValues, err := precomputedValuesFromBuffer(b)
	if err != nil {
		return nil, err
	}
	priv := rsa.PrivateKey{D: d, Primes: primes, Precomputed: *precomputedValues}
	priv.PublicKey = *pub
	return &priv, nil
}

// RsaPrivateKeyMarshalBinary encodes rsa.PrivateKey into a binary form.
func RsaPrivateKeyMarshalBinary(priv *rsa.PrivateKey) []byte {
	b := &bytes.Buffer{}
	RsaPrivateKeyToBuffer(b, priv)
	return b.Bytes()
}

// RsaPrivateKeyUnmarshalBinary decodes rsa.PrivateKey from the binary form generated by RsaPrivateKeyMarshalBinary.
func RsaPrivateKeyUnmarshalBinary(data []byte) (*rsa.PrivateKey, error) {
	b := bytes.NewBuffer(data)
	priv, err := RsaPrivateKeyFromBuffer(b)
	if err != nil {
		return nil, err
	}
	return priv, nil
}
